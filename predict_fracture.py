import cv2
import numpy as np
from skimage.feature import hog
import joblib
import os

IMAGE_SIZE = (224, 224)
HOG_ORIENTATIONS = 9
HOG_PIXELS_PER_CELL = (8, 8)
HOG_CELLS_PER_BLOCK = (2, 2)

MODEL_FILENAME = "bone_fracture_svm_model.joblib"
SCALER_FILENAME = "scaler.joblib"
PCA_FILENAME = "pca_transformer.joblib"

def preprocess_image(image_path: str, target_size: tuple[int, int]) -> np.ndarray | None:
    """
    Loads, resizes, and normalizes a grayscale image.
    """
    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
    if img is None:
        print(f"Error: Could not read image {image_path}")
        return None
    img_resized = cv2.resize(img, target_size)
    img_normalized = img_resized / 255.0
    return img_normalized

def extract_hog_features(image: np.ndarray) -> np.ndarray:
    """
    Extracts HOG features from a single image.
    """
    features = hog(image,
                   orientations=HOG_ORIENTATIONS,
                   pixels_per_cell=HOG_PIXELS_PER_CELL,
                   cells_per_block=HOG_CELLS_PER_BLOCK,
                   block_norm='L2-Hys', # Common normalization
                   visualize=False, 
                   transform_sqrt=True, 
                   feature_vector=True) 
    return features

if __name__ == "__main__":
    new_image_path = input("Please enter the full path to the new X-ray image: ")

    if not os.path.exists(new_image_path):
        print(f"Error: The file '{new_image_path}' does not exist. Please check the path.")
        exit()

    print(f"Loading model: {MODEL_FILENAME}")
    print(f"Loading scaler: {SCALER_FILENAME}")
    print(f"Loading PCA transformer: {PCA_FILENAME}")
    try:
        model = joblib.load(MODEL_FILENAME)
        scaler = joblib.load(SCALER_FILENAME)
        pca = joblib.load(PCA_FILENAME)
        print("Model and transformers loaded successfully.")
    except FileNotFoundError:
        print(f"Error: Ensure '{MODEL_FILENAME}', '{SCALER_FILENAME}', and '{PCA_FILENAME}' exist in the current directory.")
        print("These files are generated by running training.py first.")
        exit()
    except Exception as e:
        print(f"Error loading model/scaler/pca files: {e}")
        exit()

    # 2. Preprocess the new image
    print(f"\nPreprocessing image: {new_image_path}")
    processed_image = preprocess_image(new_image_path, IMAGE_SIZE)

    if processed_image is None:
        exit() 

    print("Extracting HOG features...")
    hog_features_new_image = extract_hog_features(processed_image)
    hog_features_new_image_reshaped = hog_features_new_image.reshape(1, -1)
    print(f"HOG features extracted. Shape: {hog_features_new_image_reshaped.shape}")

    print("Scaling features...")
    scaled_features_new_image = scaler.transform(hog_features_new_image_reshaped)

    print("Applying PCA transformation...")
    pca_features_new_image = pca.transform(scaled_features_new_image)
    print(f"Features after PCA. Shape: {pca_features_new_image.shape}")

    print("Making prediction...")
    prediction_numeric = model.predict(pca_features_new_image)
    
    try:
        probability_scores = model.predict_proba(pca_features_new_image)
    except AttributeError:
        probability_scores = None # Model does not support predict_proba
        print("Warning: The loaded model does not support probability scores.")

    
    class_labels_map_from_training = {0: "Fractured", 1: "NonFractured"} 

    predicted_label = class_labels_map_from_training.get(prediction_numeric[0], "Unknown Label")

    print(f"\n--- Prediction Result ---")
    print(f"The model predicts the image '{os.path.basename(new_image_path)}' as: {predicted_label}")
    
    if probability_scores is not None:
        prob_fractured = probability_scores[0][class_labels_map_from_training.inverse_lookup("Fractured")] if "Fractured" in class_labels_map_from_training.values() else "N/A"
        prob_non_fractured = probability_scores[0][class_labels_map_from_training.inverse_lookup("NonFractured")] if "NonFractured" in class_labels_map_from_training.values() else "N/A"
        
        print("Confidence Scores:")
        for i, class_name in class_labels_map_from_training.items():
            if i < len(probability_scores[0]):
                 print(f"  {class_name}: {probability_scores[0][i]:.2%}")
            else:
                print(f"  {class_name}: Score not available")

    print("\nNote: Ensure the class label mapping (Fractured/NonFractured to 0/1) in this script matches the one used during training.") 
